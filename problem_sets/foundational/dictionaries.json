{
  "Dictionaries": {
    "Foundational": {
      "1": {
        "theme": "Botanical Garden Tour",
        "problems": [
          {
            "problem_number": 1,
            "problem_name": "Garden Catalog Creation",
            "problem_instructions": "At the garden gate, you receive two lists: `plant_names` and their `descriptions`. Write `build_catalog` to return a dictionary mapping each plant name to its description.",
            "example_usage": "plant_names = [\"Rose\", \"Tulip\"]\ndescriptions = [\"A classic red bloom\", \"A cheerful spring bulb\"]\nprint(build_catalog(plant_names, descriptions))\n\nplant_names = []\ndescriptions = []\nprint(build_catalog(plant_names, descriptions))\n\nplant_names = [\"Fern\"]\ndescriptions = [\"A lush green fronded plant\"]\nprint(build_catalog(plant_names, descriptions))",
            "example_output": "{\"Rose\": \"A classic red bloom\", \"Tulip\": \"A cheerful spring bulb\"}\n{}\n{\"Fern\": \"A lush green fronded plant\"}",
            "given_python": "def build_catalog(plant_names, descriptions):\n    pass",
            "given_java": "public static Map<String, String> buildCatalog(List<String> plantNames, List<String> descriptions) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, std::string> buildCatalog(const std::vector<std::string>& plantNames, const std::vector<std::string>& descriptions) {\n    // TODO\n}",
            "given_javascript": "function buildCatalog(plantNames, descriptions) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 2,
            "problem_name": "Check Plant Presence",
            "problem_instructions": "A visitor asks if a special plant is in the catalog. Given `garden_catalog` and `query_plant`, write `has_plant` that returns `True` if `query_plant` is a key, otherwise `False`.",
            "example_usage": "garden_catalog = {\"Rose\": \"Red bloom\", \"Oak\": \"Majestic tree\"}\nprint(has_plant(garden_catalog, \"Oak\"))\n\nprint(has_plant(garden_catalog, \"Tulip\"))\n\nempty_catalog = {}\nprint(has_plant(empty_catalog, \"Fern\"))",
            "example_output": "True\nFalse\nFalse",
            "given_python": "def has_plant(garden_catalog, query_plant):\n    pass",
            "given_java": "public static boolean hasPlant(Map<String, String> gardenCatalog, String queryPlant) {\n    // TODO\n}",
            "given_cpp": "bool hasPlant(const std::map<std::string, std::string>& gardenCatalog, const std::string& queryPlant) {\n    // TODO\n}",
            "given_javascript": "function hasPlant(gardenCatalog, queryPlant) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 3,
            "problem_name": "Add New Donation",
            "problem_instructions": "At the donation desk, a gardener donates `new_plant` with its `new_description`. Write `add_plant` to insert or update that entry in `garden_catalog` and return the updated dictionary.",
            "example_usage": "garden_catalog = {}\nprint(add_plant(garden_catalog, \"Lily\", \"Elegant white blossom\"))\n\nexisting = {\"Rose\": \"Red bloom\"}\nprint(add_plant(existing, \"Tulip\", \"Yellow spring flower\"))\n\nprint(add_plant(existing, \"Rose\", \"Deep crimson bloom\"))",
            "example_output": "{\"Lily\": \"Elegant white blossom\"}\n{\"Rose\": \"Red bloom\", \"Tulip\": \"Yellow spring flower\"}\n{\"Rose\": \"Deep crimson bloom\", \"Tulip\": \"Yellow spring flower\"}",
            "given_python": "def add_plant(garden_catalog, new_plant, new_description):\n    pass",
            "given_java": "public static Map<String, String> addPlant(Map<String, String> gardenCatalog, String newPlant, String newDescription) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, std::string> addPlant(std::map<std::string, std::string> gardenCatalog, const std::string& newPlant, const std::string& newDescription) {\n    // TODO\n}",
            "given_javascript": "function addPlant(gardenCatalog, newPlant, newDescription) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 4,
            "problem_name": "Remove Wilting Plant",
            "problem_instructions": "A wilting `wilted_plant` must be removed from `garden_catalog`. Write `remove_plant` to delete the entry if it exists and return the updated dictionary.",
            "example_usage": "garden_catalog = {\"Fern\": \"Leafy green\"}\nprint(remove_plant(garden_catalog, \"Fern\"))\n\ngarden_catalog = {\"Rose\": \"Red bloom\"}\nprint(remove_plant(garden_catalog, \"Tulip\"))\n\nempty_catalog = {}\nprint(remove_plant(empty_catalog, \"Oak\"))",
            "example_output": "{}\n{\"Rose\": \"Red bloom\"}\n{}",
            "given_python": "def remove_plant(garden_catalog, wilted_plant):\n    pass",
            "given_java": "public static Map<String, String> removePlant(Map<String, String> gardenCatalog, String wiltedPlant) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, std::string> removePlant(std::map<std::string, std::string> gardenCatalog, const std::string& wiltedPlant) {\n    // TODO\n}",
            "given_javascript": "function removePlant(gardenCatalog, wiltedPlant) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 5,
            "problem_name": "Combine Neighbor Gardens",
            "problem_instructions": "You’ve been given your `garden_catalog` and a `neighbor_catalog`. Write `merge_catalogs` to combine them into one dictionary. If a plant appears in both, use the neighbor’s description.",
            "example_usage": "mine = {\"Rose\": \"Red bloom\"}\nthem = {\"Tulip\": \"Yellow spring flower\"}\nprint(merge_catalogs(mine, them))\n\na = {\"Fern\": \"Green frond\"}\nb = {\"Fern\": \"Fiddlehead fern\", \"Oak\": \"Sturdy tree\"}\nprint(merge_catalogs(a, b))\n\nprint(merge_catalogs({}, {}))",
            "example_output": "{\"Rose\": \"Red bloom\", \"Tulip\": \"Yellow spring flower\"}\n{\"Fern\": \"Fiddlehead fern\", \"Oak\": \"Sturdy tree\"}\n{}",
            "given_python": "def merge_catalogs(garden_catalog, neighbor_catalog):\n    pass",
            "given_java": "public static Map<String, String> mergeCatalogs(Map<String, String> gardenCatalog, Map<String, String> neighborCatalog) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, std::string> mergeCatalogs(std::map<std::string, std::string> gardenCatalog, const std::map<std::string, std::string>& neighborCatalog) {\n    // TODO\n}",
            "given_javascript": "function mergeCatalogs(gardenCatalog, neighborCatalog) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 6,
            "problem_name": "Count Plant Visits",
            "problem_instructions": "Visitors log their favorite plants in a list `visited_plants`. Write `count_visits` to return a dictionary mapping each plant to how many times it was visited.",
            "example_usage": "visits = [\"Rose\", \"Rose\", \"Tulip\"]\nprint(count_visits(visits))\n\nprint(count_visits([]))\n\nvisits = [\"Oak\"]\nprint(count_visits(visits))",
            "example_output": "{\"Rose\": 2, \"Tulip\": 1}\n{}\n{\"Oak\": 1}",
            "given_python": "def count_visits(visited_plants):\n    pass",
            "given_java": "public static Map<String, Integer> countVisits(List<String> visitedPlants) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, int> countVisits(const std::vector<std::string>& visitedPlants) {\n    // TODO\n}",
            "given_javascript": "function countVisits(visitedPlants) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 7,
            "problem_name": "Tallest Plant Finder",
            "problem_instructions": "In the conservatory, you have `plant_heights` mapping each plant to its height in meters. Write `tallest_plant` to return the name of the tallest plant. If empty, return an empty string.",
            "example_usage": "heights = {\"Oak\": 5, \"Pine\": 10, \"Birch\": 7}\nprint(tallest_plant(heights))\n\ntie = {\"Maple\": 8, \"Cedar\": 8}\nprint(tallest_plant(tie))\n\nprint(tallest_plant({}))",
            "example_output": "\"Pine\"\n\"Maple\"\n\"\"",
            "given_python": "def tallest_plant(plant_heights):\n    pass",
            "given_java": "public static String tallestPlant(Map<String, Integer> plantHeights) {\n    // TODO\n}",
            "given_cpp": "std::string tallestPlant(const std::map<std::string, int>& plantHeights) {\n    // TODO\n}",
            "given_javascript": "function tallestPlant(plantHeights) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 8,
            "problem_name": "Group By Bloom Color",
            "problem_instructions": "Each plant in `plant_colors` maps to its bloom color. Write `group_by_color` to invert this mapping, producing a dictionary where keys are colors and values are lists of plants with that color.",
            "example_usage": "colors = {\"Rose\": \"red\", \"Tulip\": \"yellow\"}\nprint(group_by_color(colors))\n\ncolors = {\"Azalea\": \"pink\", \"Peony\": \"pink\", \"Daisy\": \"white\"}\nprint(group_by_color(colors))\n\nprint(group_by_color({}))",
            "example_output": "{\"red\": [\"Rose\"], \"yellow\": [\"Tulip\"]}\n{\"pink\": [\"Azalea\", \"Peony\"], \"white\": [\"Daisy\"]}\n{}",
            "given_python": "def group_by_color(plant_colors):\n    pass",
            "given_java": "public static Map<String, List<String>> groupByColor(Map<String, String> plantColors) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, std::vector<std::string>> groupByColor(const std::map<std::string, std::string>& plantColors) {\n    // TODO\n}",
            "given_javascript": "function groupByColor(plantColors) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 9,
            "problem_name": "Filter Rare Species",
            "problem_instructions": "In the rare-species greenhouse, `species_counts` maps each species to its count. Write `filter_rare_species` to return a dictionary of those with count less than or equal to `max_count`.",
            "example_usage": "counts = {\"Orchid\": 2, \"Moss\": 10, \"Cactus\": 3}\nprint(filter_rare_species(counts, 3))\n\nprint(filter_rare_species(counts, 1))\n\nprint(filter_rare_species({}, 5))",
            "example_output": "{\"Orchid\": 2, \"Cactus\": 3}\n{}\n{}",
            "given_python": "def filter_rare_species(species_counts, max_count):\n    pass",
            "given_java": "public static Map<String, Integer> filterRareSpecies(Map<String, Integer> speciesCounts, int maxCount) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, int> filterRareSpecies(const std::map<std::string, int>& speciesCounts, int maxCount) {\n    // TODO\n}",
            "given_javascript": "function filterRareSpecies(speciesCounts, maxCount) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 10,
            "problem_name": "Section Plant Summary",
            "problem_instructions": "The garden is divided into `sections`, each mapping to a dictionary of plant names and their counts. Write `section_totals` to return a dictionary mapping each section name to the total number of plants in that section.",
            "example_usage": "sections = {\"East\": {\"Rose\": 3, \"Tulip\": 2}, \"West\": {\"Oak\": 1}}\nprint(section_totals(sections))\n\nsections = {\"North\": {}}\nprint(section_totals(sections))\n\nprint(section_totals({}))",
            "example_output": "{\"East\": 5, \"West\": 1}\n{\"North\": 0}\n{}",
            "given_python": "def section_totals(sections):\n    pass",
            "given_java": "public static Map<String, Integer> sectionTotals(Map<String, Map<String, Integer>> sections) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string, int> sectionTotals(const std::map<std::string, std::map<std::string, int>>& sections) {\n    // TODO\n}",
            "given_javascript": "function sectionTotals(sections) {\n    // TODO\n}",
            "visual": null
          }
        ]
      },

      "2": {
        "problems": [
          {
            "problem_number": 1,
            "problem_name": "Get Resource Quantity",
            "problem_instructions": "On the space station, you need to check how much of a resource you have. Given `cargo_manifest` and a `resource_name`, write `get_resource_quantity` to return its quantity; if it's not present, return 0.",
            "example_usage": "cargo_manifest = {\"Oxygen\": 50, \"Hydrogen\": 100}\nprint(get_resource_quantity(cargo_manifest, \"Oxygen\"))\n\ncargo_manifest = {\"Water\": 200}\nprint(get_resource_quantity(cargo_manifest, \"Nitrogen\"))\n\ncargo_manifest = {}\nprint(get_resource_quantity(cargo_manifest, \"Helium\"))",
            "example_output": "50\n0\n0",
            "given_python": "def get_resource_quantity(cargo_manifest, resource_name):\n    pass",
            "given_java": "public static int getResourceQuantity(Map<String, Integer> cargoManifest, String resourceName) {\n    // TODO\n}",
            "given_cpp": "int getResourceQuantity(const std::map<std::string, int>& cargoManifest, const std::string& resourceName) {\n    // TODO\n}",
            "given_javascript": "function getResourceQuantity(cargoManifest, resourceName) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 2,
            "problem_name": "List All Resources",
            "problem_instructions": "The AI needs an overview of what you carry. Given `cargo_manifest`, write `list_resources` to return a sorted list of all resource names.",
            "example_usage": "cargo_manifest = {\"Food\": 100, \"Water\": 200, \"Fuel\": 500}\nprint(list_resources(cargo_manifest))\n\nprint(list_resources({}))\n\ncargo_manifest = {\"Oxygen\": 50}\nprint(list_resources(cargo_manifest))",
            "example_output": "[\"Food\", \"Fuel\", \"Water\"]\n[]\n[\"Oxygen\"]",
            "given_python": "def list_resources(cargo_manifest):\n    pass",
            "given_java": "public static List<String> listResources(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "std::vector<std::string> listResources(const std::map<std::string, int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function listResources(cargoManifest) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 3,
            "problem_name": "List Quantities",
            "problem_instructions": "You need the raw quantities for analysis. Given `cargo_manifest`, write `list_quantities` to return a list of its values in insertion order.",
            "example_usage": "cargo_manifest = {\"Food\": 100, \"Water\": 200, \"Fuel\": 500}\nprint(list_quantities(cargo_manifest))\n\nprint(list_quantities({}))\n\ncargo_manifest = {\"Oxygen\": 50, \"Nitrogen\": 20, \"Helium\": 20}\nprint(list_quantities(cargo_manifest))",
            "example_output": "[100, 200, 500]\n[]\n[50, 20, 20]",
            "given_python": "def list_quantities(cargo_manifest):\n    pass",
            "given_java": "public static List<Integer> listQuantities(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "std::vector<int> listQuantities(const std::map<std::string, int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function listQuantities(cargoManifest) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 4,
            "problem_name": "List Manifest Entries",
            "problem_instructions": "The command console shows entries as pairs. Given `cargo_manifest`, write `list_manifest_entries` to return a list of `[resource, quantity]` pairs.",
            "example_usage": "cargo_manifest = {\"Fuel\": 500, \"Water\": 200}\nprint(list_manifest_entries(cargo_manifest))\n\nprint(list_manifest_entries({}))\n\ncargo_manifest = {\"Oxygen\": 50}\nprint(list_manifest_entries(cargo_manifest))",
            "example_output": "[[\"Fuel\", 500], [\"Water\", 200]]\n[]\n[[\"Oxygen\", 50]]",
            "given_python": "def list_manifest_entries(cargo_manifest):\n    pass",
            "given_java": "public static List<List<Object>> listManifestEntries(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "std::vector<std::vector<std::variant<std::string,int>>> listManifestEntries(const std::map<std::string, int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function listManifestEntries(cargoManifest) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 5,
            "problem_name": "Total Cargo Weight",
            "problem_instructions": "Mission control needs the grand total. Given `cargo_manifest`, write `total_cargo` to return the sum of all quantities.",
            "example_usage": "cargo_manifest = {\"Fuel\": 500, \"Water\": 200}\nprint(total_cargo(cargo_manifest))\n\nprint(total_cargo({}))\n\ncargo_manifest = {\"Oxygen\": 50, \"Nitrogen\": 20}\nprint(total_cargo(cargo_manifest))",
            "example_output": "700\n0\n70",
            "given_python": "def total_cargo(cargo_manifest):\n    pass",
            "given_java": "public static int totalCargo(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "int totalCargo(const std::map<std::string, int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function totalCargo(cargoManifest) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 6,
            "problem_name": "Invert Manifest",
            "problem_instructions": "To speed lookup, you need a reverse map of quantity to resource. Given a one‑to‑one `cargo_manifest`, write `invert_manifest` to swap keys and values.",
            "example_usage": "cargo_manifest = {\"Fuel\": 500, \"Water\": 200}\nprint(invert_manifest(cargo_manifest))\n\ncargo_manifest = {\"Oxygen\": 50, \"Hydrogen\": 50}\nprint(invert_manifest(cargo_manifest))\n\nprint(invert_manifest({}))",
            "example_output": "{\"500\": \"Fuel\", \"200\": \"Water\"}\n{\"50\": \"Oxygen\"}\n{}",
            "given_python": "def invert_manifest(cargo_manifest):\n    pass",
            "given_java": "public static Map<Integer,String> invertManifest(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "std::map<int, std::string> invertManifest(const std::map<std::string,int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function invertManifest(cargoManifest) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 7,
            "problem_name": "Merge Manifests with Totals",
            "problem_instructions": "When two freighters dock, combine their manifests by summing shared resources. Given `manifest_a` and `manifest_b`, write `merge_manifests` to return the summed result.",
            "example_usage": "manifest_a = {\"Fuel\": 500, \"Water\": 200}\nmanifest_b = {\"Water\": 100, \"Oxygen\": 50}\nprint(merge_manifests(manifest_a, manifest_b))\n\nprint(merge_manifests({}, {\"Helium\": 20}))\n\nprint(merge_manifests({}, {}))",
            "example_output": "{\"Fuel\": 500, \"Water\": 300, \"Oxygen\": 50}\n{\"Helium\": 20}\n{}",
            "given_python": "def merge_manifests(manifest_a, manifest_b):\n    pass",
            "given_java": "public static Map<String, Integer> mergeManifests(Map<String, Integer> a, Map<String, Integer> b) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> mergeManifests(const std::map<std::string,int>& a, const std::map<std::string,int>& b) {\n    // TODO\n}",
            "given_javascript": "function mergeManifests(manifestA, manifestB) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 8,
            "problem_name": "Clear the Cargo",
            "problem_instructions": "Before pressurization, you must jettison all cargo. Given `cargo_manifest`, write `clear_manifest` to remove all entries and return the empty dictionary.",
            "example_usage": "cargo_manifest = {\"Fuel\": 500, \"Water\": 200}\nprint(clear_manifest(cargo_manifest))\n\ncargo_manifest = {}\nprint(clear_manifest(cargo_manifest))\n\ncargo_manifest = {\"Oxygen\": 50}\nprint(clear_manifest(cargo_manifest))",
            "example_output": "{}\n{}\n{}",
            "given_python": "def clear_manifest(cargo_manifest):\n    pass",
            "given_java": "public static Map<String, Integer> clearManifest(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> clearManifest(std::map<std::string,int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function clearManifest(cargoManifest) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 9,
            "problem_name": "Filter by Prefix",
            "problem_instructions": "To prioritize certain supplies, filter by name. Given `cargo_manifest` and a string `prefix`, write `filter_resources_by_prefix` to keep only entries whose key starts with that prefix.",
            "example_usage": "cargo_manifest = {\"Oxygen\": 50, \"Hydrogen\": 100, \"Helium\": 25}\nprint(filter_resources_by_prefix(cargo_manifest, \"H\"))\n\nprint(filter_resources_by_prefix(cargo_manifest, \"O\"))\n\nprint(filter_resources_by_prefix({}, \"X\"))",
            "example_output": "{\"Hydrogen\": 100, \"Helium\": 25}\n{\"Oxygen\": 50}\n{}",
            "given_python": "def filter_resources_by_prefix(cargo_manifest, prefix):\n    pass",
            "given_java": "public static Map<String, Integer> filterResourcesByPrefix(Map<String, Integer> cargoManifest, String prefix) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> filterResourcesByPrefix(const std::map<std::string,int>& cargoManifest, const std::string& prefix) {\n    // TODO\n}",
            "given_javascript": "function filterResourcesByPrefix(cargoManifest, prefix) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 10,
            "problem_name": "Uppercase Resource Names",
            "problem_instructions": "For a final status report, resource names must be in all caps. Given `cargo_manifest`, write `uppercase_manifest` to return a new dictionary with every key uppercased and values unchanged.",
            "example_usage": "cargo_manifest = {\"oxygen\": 50, \"hydrogen\": 100}\nprint(uppercase_manifest(cargo_manifest))\n\ncargo_manifest = {}\nprint(uppercase_manifest(cargo_manifest))\n\ncargo_manifest = {\"Fuel\": 500}\nprint(uppercase_manifest(cargo_manifest))",
            "example_output": "{\"OXYGEN\": 50, \"HYDROGEN\": 100}\n{}\n{\"FUEL\": 500}",
            "given_python": "def uppercase_manifest(cargo_manifest):\n    pass",
            "given_java": "public static Map<String, Integer> uppercaseManifest(Map<String, Integer> cargoManifest) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> uppercaseManifest(const std::map<std::string,int>& cargoManifest) {\n    // TODO\n}",
            "given_javascript": "function uppercaseManifest(cargoManifest) {\n    // TODO\n}",
            "visual": null
          }
        ]
      },

      "3": {
        "theme": "Royal Archives Expedition",
        "problems": [
          {
            "problem_number": 1,
            "problem_name": "Retrieve and Remove Old Tome",
            "problem_instructions": "The archivist needs to remove an outdated tome. Given `archive_catalog` and `tome_title`, write `pop_tome` to remove that key and return its count; if missing, return 0.",
            "example_usage": "archive_catalog = {\"Grimoire\": 2, \"Atlas\": 1}\nprint(pop_tome(archive_catalog, \"Grimoire\"))\n\narchive_catalog = {\"Chronicle\": 5}\nprint(pop_tome(archive_catalog, \"Tome of Kings\"))\n\narchive_catalog = {}\nprint(pop_tome(archive_catalog, \"Atlas\"))",
            "example_output": "2\n0\n0",
            "given_python": "def pop_tome(archive_catalog, tome_title):\n    pass",
            "given_java": "public static int popTome(Map<String, Integer> archiveCatalog, String tomeTitle) {\n    // TODO\n}",
            "given_cpp": "int popTome(std::map<std::string,int>& archiveCatalog, const std::string& tomeTitle) {\n    // TODO\n}",
            "given_javascript": "function popTome(archiveCatalog, tomeTitle) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 2,
            "problem_name": "Discard Last Entry",
            "problem_instructions": "To purge the latest record, write `pop_last_entry` that removes and returns the last inserted `[tome, count]` pair from `archive_catalog`; return `[]` if empty.",
            "example_usage": "archive_catalog = {\"Codex\": 3, \"Scroll\": 4}\nprint(pop_last_entry(archive_catalog))\n\narchive_catalog = {\"Tome\": 1}\nprint(pop_last_entry(archive_catalog))\n\narchive_catalog = {}\nprint(pop_last_entry(archive_catalog))",
            "example_output": "[\"Scroll\", 4]\n[\"Tome\", 1]\n[]",
            "given_python": "def pop_last_entry(archive_catalog):\n    pass",
            "given_java": "public static List<Object> popLastEntry(Map<String, Integer> archiveCatalog) {\n    // TODO\n}",
            "given_cpp": "std::vector<std::variant<std::string,int>> popLastEntry(std::map<std::string,int>& archiveCatalog) {\n    // TODO\n}",
            "given_javascript": "function popLastEntry(archiveCatalog) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 3,
            "problem_name": "Ensure Archive Section",
            "problem_instructions": "Before cataloging begins, ensure a section exists. Given `archive_catalog` and `section_name`, write `ensure_section` that sets `section_name` to an empty dictionary if missing and returns its dictionary.",
            "example_usage": "archive_catalog = {\"Herbals\": {\"Plant Lore\": 2}}\nprint(ensure_section(archive_catalog, \"Maps\"))\n\nprint(ensure_section(archive_catalog, \"Herbals\"))\n\narchive_catalog = {}\nprint(ensure_section(archive_catalog, \"Annals\"))",
            "example_output": "{}\n{\"Plant Lore\": 2}\n{}",
            "given_python": "def ensure_section(archive_catalog, section_name):\n    pass",
            "given_java": "public static Map<String,Integer> ensureSection(Map<String, Map<String,Integer>> archiveCatalog, String sectionName) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int>& ensureSection(std::map<std::string,std::map<std::string,int>>& archiveCatalog, const std::string& sectionName) {\n    // TODO\n}",
            "given_javascript": "function ensureSection(archiveCatalog, sectionName) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 4,
            "problem_name": "Merge New Records",
            "problem_instructions": "A visiting scribe provides `new_entries`. Given `archive_catalog` and `new_entries`, write `update_catalog` to in‑place update `archive_catalog` with `new_entries` and return it.",
            "example_usage": "archive_catalog = {\"Atlas\": 1}\nnew_entries = {\"Atlas\": 2, \"Grimoire\": 3}\nprint(update_catalog(archive_catalog, new_entries))\n\narchive_catalog = {}\nprint(update_catalog(archive_catalog, {\"Scroll\": 5}))\n\nprint(update_catalog(archive_catalog, {}))",
            "example_output": "{\"Atlas\": 2, \"Grimoire\": 3}\n{\"Scroll\": 5}\n{\"Scroll\": 5}",
            "given_python": "def update_catalog(archive_catalog, new_entries):\n    pass",
            "given_java": "public static Map<String,Integer> updateCatalog(Map<String,Integer> archiveCatalog, Map<String,Integer> newEntries) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int>& updateCatalog(std::map<std::string,int>& archiveCatalog, const std::map<std::string,int>& newEntries) {\n    // TODO\n}",
            "given_javascript": "function updateCatalog(archiveCatalog, newEntries) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 5,
            "problem_name": "Initialize Empty Sections",
            "problem_instructions": "The archivist prepares empty shelves. Given a list `section_names` and a `default_list`, write `init_sections` to return a dictionary from each section to a copy of `default_list`.",
            "example_usage": "section_names = [\"Myths\", \"Law\"]\ndefault_list = []\nprint(init_sections(section_names, default_list))\n\nprint(init_sections([], [\"Empty\"]))\n\nprint(init_sections([\"Lore\"], [1, 2, 3]))",
            "example_output": "{\"Myths\": [], \"Law\": []}\n{}\n{\"Lore\": [1, 2, 3]}",
            "given_python": "def init_sections(section_names, default_list):\n    pass",
            "given_java": "public static Map<String,List<Object>> initSections(List<String> sectionNames, List<Object> defaultList) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,std::vector<std::any>> initSections(const std::vector<std::string>& sectionNames, const std::vector<std::any>& defaultList) {\n    // TODO\n}",
            "given_javascript": "function initSections(sectionNames, defaultList) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 6,
            "problem_name": "Compare Two Catalogues",
            "problem_instructions": "Two ledgers must match exactly. Given `ledger_a` and `ledger_b`, write `ledgers_equal` to return `True` if they have identical keys and values, else `False`.",
            "example_usage": "a = {\"Atlas\": 1, \"Grimoire\": 2}\nb = {\"Grimoire\": 2, \"Atlas\": 1}\nprint(ledgers_equal(a, b))\n\na = {\"Atlas\": 1}\nb = {\"Atlas\": 2}\nprint(ledgers_equal(a, b))\n\nprint(ledgers_equal({}, {}))",
            "example_output": "True\nFalse\nTrue",
            "given_python": "def ledgers_equal(ledger_a, ledger_b):\n    pass",
            "given_java": "public static boolean ledgersEqual(Map<String,Integer> a, Map<String,Integer> b) {\n    // TODO\n}",
            "given_cpp": "bool ledgersEqual(const std::map<std::string,int>& a, const std::map<std::string,int>& b) {\n    // TODO\n}",
            "given_javascript": "function ledgersEqual(ledgerA, ledgerB) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 7,
            "problem_name": "Duplicate Catalogue",
            "problem_instructions": "Before experiments, the archivist clones the catalog. Given `archive_catalog`, write `copy_catalogue` to return a shallow copy without modifying the original.",
            "example_usage": "original = {\"Lore\": 3}\ncopy = copy_catalogue(original)\ncopy[\"Lore\"] = 5\nprint(original)\nprint(copy)\n\nprint(copy_catalogue({}))\n\nprint(copy_catalogue({\"Tome\": 1}))",
            "example_output": "{\"Lore\": 3}\n{\"Lore\": 5}\n{}\n{\"Tome\": 1}",
            "given_python": "def copy_catalogue(archive_catalog):\n    pass",
            "given_java": "public static Map<String,Integer> copyCatalogue(Map<String,Integer> archiveCatalog) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> copyCatalogue(const std::map<std::string,int>& archiveCatalog) {\n    // TODO\n}",
            "given_javascript": "function copyCatalogue(archiveCatalog) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 8,
            "problem_name": "Increment All Tome Counts",
            "problem_instructions": "After a kingdom census, increase every tome count by `increment`. Given `archive_catalog` and `increment`, write `increment_tomes` to return a new dictionary with updated values.",
            "example_usage": "archive_catalog = {\"Codex\": 2, \"Scroll\": 3}\nprint(increment_tomes(archive_catalog, 1))\n\nprint(increment_tomes({}, 5))\n\nprint(increment_tomes({\"Atlas\": 0}, 10))",
            "example_output": "{\"Codex\": 3, \"Scroll\": 4}\n{}\n{\"Atlas\": 10}",
            "given_python": "def increment_tomes(archive_catalog, increment):\n    pass",
            "given_java": "public static Map<String,Integer> incrementTomes(Map<String,Integer> archiveCatalog, int increment) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> incrementTomes(const std::map<std::string,int>& archiveCatalog, int increment) {\n    // TODO\n}",
            "given_javascript": "function incrementTomes(archiveCatalog, increment) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 9,
            "problem_name": "Flatten Sectioned Catalog",
            "problem_instructions": "The archives are nested by section. Given `sectioned_catalog` mapping each section to its own dict, write `flatten_sectioned_catalog` to return a single dictionary with keys joined by `\".\"` (e.g. `\"Myths.Lore\"`).",
            "example_usage": "sections = {\"Myths\": {\"Lore\": 2}, \"Maps\": {\"Atlas\": 1}}\nprint(flatten_sectioned_catalog(sections))\n\nprint(flatten_sectioned_catalog({}))\n\nsections = {\"Herbals\": {}}\nprint(flatten_sectioned_catalog(sections))",
            "example_output": "{\"Myths.Lore\": 2, \"Maps.Atlas\": 1}\n{}\n{}",
            "given_python": "def flatten_sectioned_catalog(sectioned_catalog):\n    pass",
            "given_java": "public static Map<String,Integer> flattenSectionedCatalog(Map<String, Map<String,Integer>> sectionedCatalog) {\n    // TODO\n}",
            "given_cpp": "std::map<std::string,int> flattenSectionedCatalog(const std::map<std::string,std::map<std::string,int>>& sectionedCatalog) {\n    // TODO\n}",
            "given_javascript": "function flattenSectionedCatalog(sectionedCatalog) {\n    // TODO\n}",
            "visual": null
          },
          {
            "problem_number": 10,
            "problem_name": "Export Catalog to JSON",
            "problem_instructions": "For the royal decree, export the catalog as a JSON string sorted by keys. Given `archive_catalog`, write `export_catalog_json` to return that string.",
            "example_usage": "archive_catalog = {\"Scroll\": 3,\"Atlas\": 1}\nprint(export_catalog_json(archive_catalog))\n\nprint(export_catalog_json({}))\n\narchive_catalog = {\"Codex\": 0}\nprint(export_catalog_json(archive_catalog))",
            "example_output": "\"{\"Atlas\": 1, \"Scroll\": 3}\"\n\"{}\"\n\"{\"Codex\": 0}\"",
            "given_python": "def export_catalog_json(archive_catalog):\n    pass",
            "given_java": "public static String exportCatalogJson(Map<String,Integer> archiveCatalog) {\n    // TODO\n}",
            "given_cpp": "std::string exportCatalogJson(const std::map<std::string,int>& archiveCatalog) {\n    // TODO\n}",
            "given_javascript": "function exportCatalogJson(archiveCatalog) {\n    // TODO\n}",
            "visual": null
          }
        ]
      }
    }
  }
}
